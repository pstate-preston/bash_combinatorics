#!/bin/bash

# permute_m [n] [# of repeating elements 1...] [# of repeating elements 2...] [# of repeating elements ...n]
# This script computes the total possible number of permutations of a set with repeating, non-distinguishable elements. Meaning, not each element of the set is disjoint from all other elements.
# This is to find the possible permutations of a set with cardinality n without repeated choices. Such as the set [A, B, C, C, C, D]. It would make no sense with repeated choices, as any choice for
# C is the same as any other position of C. Thus, this formula shows the number of possible permutations given that are a finite number of repeated choices for only certain elements.

# Mathematically, this is refered to as the permutation of a multiset, hence permute_m.
# idea: how many ways can you arrange a set of items on a shelf, when there are a finite amount of repeated items?

# PermuteM(n, 1, 2,... ,m) = n!/(m1!m2!m3!....mn!) , where m is the number of times the element repeats in the set, and n is the cardinality of the set
# example: set A := [1, 2, 2, 2, 3, 4, 4, 5]
#	   PermuteM(8, 1, 3, 1, 2, 1) = 8!/(1!*3!*1!*2!*1!)

permute_m(){

# defining n as the first argument(cardinality of the set).
# After qualifying n, shift will remove the first argument passed into the function shift the rest to the left. This will happen any time shift is called in a script/function.
# Keep in mind that after the shift, $1 will have a new value.
# Once all elements are shifted to not include n, we can initialize repeats to store all of the remaining elements as a vector array using ( ) around the remaining arguments.
# ---- KEEP THIS IN MIND for designing array inputs of sets ----

	local n="$1"
	shift
	local repeats=("$@")

# Define help flag
	if [[ "$n" == "-h" || "$n" == "--help" ]]; then
		printf "This function computes the number of permutations of a multiset. \nUsage: permute_m [n] [# of repeating elements 1...] [# of repeating elements 2...] [# of repeating elements ...n]\n"
		printf "Where n is the cardinality of the set, and the remaining arguments are the count of each repeating elements."
		printf " Non-repeating elements can be ignored.\n\n"
		exit 0
	fi

# Check for null arguments. If the first entry is empty, or the length of the array containing the rest of the entries equals zero throw error.
# -----NOTE ${#repeats[1]} would be the second element in the remaining set. The {} brackets are for array expansion, as opposed to () variable expansion.
	if [[ -z "$n" || (( ${#repeats[@]} == 0 )) ]]; then
		printf "Error: function needs at least two arguments.\nTry including -h or --help flags for usage.\n\n" >&2
		return 1
	fi

# Ensure all entries are non-negative integers. Must do so with a loop, since we are dealing with an array.
# First, the value of n is checked.
# Then we must use a loop to check the rest. First, the sum of the entries is declared. As each element is regex checked,
# the sum is of the elements is stored. Remember this is only the repeating elements of the set, so the total should not be expected to equal n.
	if [[ ! "$n" =~ ^[0-9]+$ ]]; then
		printf "Error: cardinality[n] of the set must be a non-negative integer/n/n" >&2
		return 1
	fi

	local sum=0
	for count in "${repeats[@]}"; do
		if [[ ! "$count" =~ ^[0-9]+$ ]]; then
			printf "Error: number repeated elements[m] must be non-negative integers.\n\n"
			return 1
		fi
		sum=$(( sum + count ))
	done

# Following the definition of n, all other entries must be smaller than n
	if (( n < sum )); then
		printf "Error: the cardinality of the set must be larger than the number of elements in the set.\nTry including -h or --help flags for usage.\n\n" >&2
		return 1
	fi

# Define mathematical operations
# First, compute denominator using a for loop and factorial script
# Compute n! and then divide, passing to bc for dealing with large numbers.
	denominator=1
	for count in "${repeats[@]}"; do
		f=$(factorial "$count")
		denominator=$(( denominator * f ))
	done

	numerator=$(factorial "$n")

	solution=$( echo "scale=0; $numerator/$denominator" | bc )

	echo "$solution"

}

# Pass all arguments given to the script into the function created above
permute_m "$@"
